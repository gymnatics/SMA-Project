---
title: "Analysis of Simulation"
author: "Danny Yeo"
date: "2023-04-19"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: united
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

## Batch Means Approach
Due to the time constraints, we chose to do do the Batch Means approach for data collection. This is because each of our runs take about 1 hour, so in order to do 25 runs it would take over a day. We could have replicated the runs but we believed that if we were replicating the runs it would be better to just do the batch means approach.

### Read csv for 3 ride type data

```{r}
sim_data3 <- read.csv("3_rides_data.csv")

head(sim_data3)
```
```{r}
bm <- function(vals,bs="sqroot",warn=FALSE)
  {
    N <- length(vals)
    if (N<1000)
      {
        if (warn) # if warning
          cat("WARNING: too few samples (less than 1000)\n")
        if (N<10)
          return(NA)
      }

    if (bs=="sqroot") 
      {
        b <- floor(sqrt(N)) # batch size
        a <- floor(N/b) # number of batches
      }
    else
      if (bs=="cuberoot") 
        {
          b <- floor(N^(1/3)) # batch size
          a <- floor(N/b) # number of batches
        }
    else # batch size provided
      {
        stopifnot(is.numeric(bs))  
        b <- floor(bs) # batch size
        if (b > 1) # batch size valid
          a <- floor(N/b) # number of batches
        else
          stop("batch size invalid (bs=",bs,")")
      }
    
    Ys <- sapply(1:a,function(k) return(mean(vals[((k-1)*b+1):(k*b)])))

    muhat <- mean(Ys) # steady-state mean
    sigmahatsq <- b*sum((Ys-muhat)^2)/(a-1) # steady state variance

    bmse <- sqrt(sigmahatsq/N)

    return(list(est=muhat,se=bmse, var = sigmahatsq))
  }

## apply bm to each col of a matrix of MCMC samples
## input: mcmat is a matrix with each row corresponding to a sample from the multivariate distribution of interest
## skip = vector of columns to skip
## output: matrix with number of rows=number of dimensions of distribution and 2 columns (estimate and s.error)
bmmat=function(mcmat,skip=NA)
{
  if (!any(is.na(skip)))
    {
      num=ncol(mcmat)-length(skip)
      mcmat=mcmat[-skip] # remove columns to be skipped
    }
  else # assume it is NA
    num=ncol(mcmat)

  bmvals=matrix(NA,num,3,dimnames=list(paste("V",seq(1,num),sep=""),c("est","se","var"))) # first col=est, second col=MS s.error, third col= variance

  bmres=apply(mcmat,2,bm)
  for (i in 1:num)
    {
      bmvals[i,]=c(bmres[[i]]$est,bmres[[i]]$se, bmres[[i]]$var)
    }
  return(bmvals)
 
}
```

```{r}
bm(sim_data3$avg_wait_person, bs="sqroot")
```
```{r}
bmmat(sim_data3)
```
### Calculate confidence interval
